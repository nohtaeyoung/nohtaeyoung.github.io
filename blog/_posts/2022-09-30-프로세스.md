---
layout: post
title: Linux 프로세스 관리
subtitle: 프로세스 명령어
gh-repo: nohtaeyoung/nohtaeyoung.github.io
gh-badge: [star, fork, follow]
cover-img: /assets/img/security.jpg
tags: [Linux]
comments: true
---

## 프로세스
- <b style="color:red">프로그램이나 명령어를 실행했을 때 메모리에 적재되어 실제로 동작하는 상태</b>
- 프로세스가 실행되면 <b>프로세스 식별번호(PID, Process id)를 할당</b> 받는다.
- 최상위 프로세스는 항상 init 프로세스
- 나머지 프로세스는 항상 부모 프로세스(PPID, Parent Process ID)를 가진다
- 해당 프로세스를 동작 시킨 파일의 uid, gid를 획득하여 소유주 등의 프로세스 실행에 필요한 inode 정보 및 실행된 터미널, 입력된 명령어, 시작 시간 등의 많은 정보 보유

## 프로세스 기본 관리 명령어
- ps
- pstree
- signal
- kill
- pkill

## ps
- 프로세스의 정보 확인

## 사용법
- #ps [옵션]

|OPTIONS|
| ------------------------------ | :--------------: | 
|-a|프로세스 중에서 제어 터미널을 가지고 있는 목록 출력|
|-e, -A|프로세스 전체 목록 출력|
|-f|PID, PPID 정보를 포함하여 출력|
|-l(소문자 L)|-f 옵션보다 자세한 정보 출력|
|-u|사용자 이름과 시작된 시간을 출력|
|-x|터미널에 종속되지 않은 프로세스 목록 출력|

## ps 출력 정보
~~~
#ps -f
~~~


|UID|PID|PPID|C|STIME|TTY|TIME|CMD
| ------------------------------ | :--------------: | :--------------: | :--------------: | :--------------: | :--------------: | :--------------: | :--------------: | 
|Root|3250|3247|0|02:24|pts/0|00:00:00|Bash|
|root|3280|3250|0|02:25|pts/0|00:00:00|Bash|

| ------------------------------ | :--------------: | 
|UID|사용자의 uid|
|PID|프로세스를 운영체제가 실별하는 번호|
|PPID|해당 프로세스의 부모 프로세스 식별 번호|
|C|현재 사용 하지 않는 값|
|STIME|프로세스가 시작된 시간|
|TTY|프로세스가 실행된 터미널 포트|
|TIME|프로세스 동작을 위해 사용한 CPU 사용 시간 전체|
|CMD|실행시킨 명령어|

## pstree
- 프로세스의 상관관계를 계층적으로 확인

## 사용법
~~~
#pstree [옵션]
~~~

|OPTION|
| ------------------------------ | :--------------: | 
|-q|프로세스를 동작 시킨 명령어 까지 함께 출력|
|-n|PID 순서대로 정렬하여 출력|
|-p|PID 정보를 함께 출력|
|-U|uid 정보를 함께 출력|
|-V|버전 정보 출력|

## signal
- 동작중인 프로세스에게 전달하는 메시지의 의미를 가진다.
- 각 메시지마다 프로세스가 수행할 동작이 정의 되어있다.

##  signal 종류 확인
- #kill -i

|Signal 종류|
| ------------------------------ | :--------------: | 
|SIGHUP(1)|프로세스 실행|
|SIGINT(2)|키보드 "ctr;(인터럽트)" 기능 수행 -> 프로세스 종료|
|SIGKILL(9)|커널을 통해 직접적으로 프로세스를 종료(강제 종료) -> 프로세스가 사용중이던 데이터를 기록하지 않음|
|SIGTERM(15)|프로세스를 통해 정상 종료 -> 저장 할 데이터가 있을 경우 저장 후 종료|

## kill
- 프로세스 종료
- PID를 이용하여 종료할 프로세스를 지정 한다.

# 사용법
~~~
#kill [-signal] [PID]
~~~

## pkill
- 프로세스 종료
- 프로세스의 이름을 이용하여 종료할 프로세스를 지정 한다.
- 같은 이름으로 동작 중인 프로세스를 동시에 제어할 수 있다.

## 사용법
~~~
#pkill [-signal] [옵션] [프로세스 이름 또는 패턴]
~~~

|OPTION|
| ------------------------------ | :--------------: | 
|-f|지정한 패터을 명령어, 경로, 옵션, 인자에서도 검색|
|-n|패턴과 일치하는 프로세스 중에서 가장 최근에 실행된 하나만 종료|
|-x|패턴과 정확하게 일치되는 프로세스만 종료|

## 프로세스 우선순위
- 한번에 여러 개의 프로세스가 동작 할 수 있다.
- 여러개의 프로세스는 CPU를 사용하기 위해 경쟁 하지만 모든 프로세스가 동일한 동작을 하는 것이 아니므로 공평하게 자원을 배분 받지 못 한다.
- 프로세스의 중요도에 따라 빨리 처리가 되어야 하는 경우 우선순위가 높아진다.
- 백업, 업데이트, 용량이 큰 프로그램을 다운받을 경우 백그라운드로 동작 시키면서 우선순위를 조정 한다.

## 프로세스 우선순위 값
- -20 ~ 20(낮을 수록 우선순위가 높다.)
- nice, snice 명령어로 관리 한다.
- priority 값은 변경이 불가능하며 nice값을 이용하여 시스템이 계산한다.

## 프로세스 우선순위 확인

~~~
#ps -el
~~~

| ------------------------------ | :--------------: | 
|PRI|시스템이 nice의 데이터를 이용하여 계산한 실제 우선순위 값|
|NI|Nice에 의해 설정된 우선순위 값|

## nice
- 프로세스 동작의 우선순위를 설정
- 프로그램을 실행하면 우선순위(nicer값)를 변경

## 사용법
~~~
#nice -n [우선순위 값] [프로그램 이름 또는 PID]
#nice -[우선순위 값] [프로그램 이름 또는 PID]
~~~

## snice
- 프로세스 동작의 우선순위를 설정
- 실행중인 프로그램의 우선 순위(nice 값)를 변경

## 사용법

~~~
#snice +/- [우선순위 값] [프로그램 이름 또는 PID]
~~~

## 포그라운드(Foreground)
- 프로그램의 일반적인 실행 방식
- 사용자와 마치 대화를 하듯 입력과 출력을 통해 상호작용하며 실행하는 형태

## 백그라운드(Background)
- 프로세스 실행 중 다른 프로세스를 실행할 수 있는 형태
- 실행중인 프로세스와 입/출력을 사용할 수 없다.
- 서비스 제공을 위한 데몬 프로그램은 대부분 백그라운드 방식으로 동작 시킨다.
- 백그라운드 프로세스는 kill을 사용하여 종료 한다.

## 백그라운드로 실행
- 명령어 입력 뒤에 "&"를 붙여서 실행한다.
- 작업 번호와 PID를 출력하고 백그라운드로 실행 된다.
- <b>#firefox</b> <b style="color:red">&</b>

## JOB
- 터미널에 의해서 제어되는 프로세스
- 모든 job은 shell에 의해서 작업번호를 부여 받는다.

## jobs
- 백그라운드로 실행되고 있는 작업번호 목록 확인
- #jobs

 ![프로세스1](../assets/img/프로세스1.png)
 
 ## fg
 - 백그라운드로 동작중인 프로세스를 포그라운드로 전환
 ~~~
 #fg [작업번호]
 ~~~
 
 ## bg
 - 포그라운드로 동작중인 프로세스를 백그라운드로 전환
~~~
# bg [작업번호]
~~~

## nohub
- 쉘 스크립트 파일을 데몬 형태로 실행
- 터미널 종료 후에도 프로세스의 실행을 유지해야 하는 경우 사용
~~~
#nohup *.sh
~~~
